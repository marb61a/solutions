EXPLOIT EXERCISES - NEBULA


Level 00 - You are required to find a Set User ID program that will run as "flag00"
There are a few variations of using the find command which id needed to complete the challenge such as

find / -perm /u=s -user flag00 2>/dev/null 
or
find / -user flag00 -type f -executable 2>/dev/null/bin/.../flag00

After each run

/bin/.../flag00

followed by

getflag 

which will complete the level



Level 01 - This involves a C program which is vulnerable, the vulnerability allows for arbitrary programs
to execute. The program itself calls 'echo' and then the text 'and now what?' is sent to the screen. The 
vulnerability lies in the fact that the echo is called using the environment settings like this -

system("/usr/bin/env echo and now what?");

************************************************************************************************************
Important - The /usr/bin/env is often used by scripts that need full paths eg 
#!/usr/bin/env python is used by python scripts to get a full path to the python interpreter.
Also remember that in bash a trailing colon can be considered as a potential security hole as it causes bash to
look for an executable in the current directory.
************************************************************************************************************

This means that the path needs to be modified in order to be exploited. Again there are a few ways of 
doing this but the easiest is to create a symbolic link as symbolic links can be used for bypassing name and 
location checks

level01@nebula:~$ ln -s /bin/getflag echo

level01@nebula:~$ export PATH=.:$PATH

Then run

level01@nebula:~$ /home/flag01/flag01 

and you should see the success message



Level 02 - This level presents another challenge similar to the previous one, this time the 'USER' is being called
directly. Again manipulation of the environmental variables is needed. The solution is fairly straightforward

$ export USER=";getflag;"
./flag02

this reassigns environment variables and then runs the file

*******************************************************************************************************************
Important - In this exercise the 'USER' is copied to a buffer without checking, needless to say that passing stuff
without checking at anytime is not a good idea.
*******************************************************************************************************************



Level 03 - In this level there is a crontab that runs every 5 minutes, and executes anything found in the local 
writable.d folder, then removes it.  When you check the flag03 directory the are 2 items the writable. directory
and a writable.sh script. There are a few widely different ways that this can be completed some more complex than 
others, firstly the directory is world read/write, which will allow us to add our own script which should give the 
success message as the script should run automatically without us needing to do anything, the exploit will be just 
to run the /bin/getflag program when executed. The solution is this -

echo "/bin/getflag >> /tmp/nebscript03" > scriptflag03
cat scriptflag03/bin/getflag >> /tmp/nebflag03
cat /tmp/nebflag03
In the above you have redirected the getflag into a temp file and on into a script, you then cat the script and
send to temp file, when you cat the temp file it causes it to run and you will have captured the flag.




Level 04 - In this challenge there is the need to find a vulnerability in the provided C++ program. There are a 
couple of verifications that are carried out by the file. This is the code itself 

#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>
#include <fcntl.h>

int main(int argc, char **argv, char **envp)
{
 char buf[1024];
 int fd, rc;

 if(argc == 1) {
  printf("%s [file to read]\n", argv[0]);
  exit(EXIT_FAILURE);
 }

 if(strstr(argv[1], "token") != NULL) {
  printf("You may not access '%s'\n", argv[1]);
  exit(EXIT_FAILURE);
 }

 fd = open(argv[1], O_RDONLY);
 if(fd == -1) {
  err(EXIT_FAILURE, "Unable to open %s", argv[1]);
 }

 rc = read(fd, buf, sizeof(buf));

 if(rc == -1) {
  err(EXIT_FAILURE, "Unable to read fd %d", fd);
 }

 write(1, buf, rc);
}

The first check is to ensure that you have actually have passed a file in and the second check is to see if the
word 'token' is used, if it is then the programs exits. Unfortunately the file needed to be examined is called token
so we have to find a way around this. There is only one clean way of doing this and that is to use symbolic links
to the file and open the link which should bypass the check. Using this to create a symlink

ln -s /home/flag04/token /tmp/filename (any filename will do)

and then running the getflag by running this command

./flag04 /tmp/filename (the filename you have used to create the link)

will finish the challenge.
