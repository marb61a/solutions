This is the Nodeschool Promise It Won't Hurt set of challenges and the solutions. It is designed to help you use
promises to handle async operations.



Level 01  Fullfill a Promise -
This is the first challenge in this series and in it you are asked to use the "Q" library to create a promise. After  
that you will need to pass console.log to the "then" method of your promise. Then manually resolve that promise using 
setTimeout with a delay of 300ms and pass it a parameter of "RESOLVED!". There is boiler plate code included and as is
standard the challenge should be fairly basic. The solution is 

var q = require('q');
var defer = q.defer();

defer.promise.then(console.log);
setTimeout(defer.resolve, 300, "RESOLVED!");

Make sure that everything is in the correct order and you have included the exclamation mark as that will cause a 
failure.




Level 02  Reject A Promise -
The second in the series on Javascript promises asks us to create a function to print error.message using console.log.
Pass this function as a rejection handler to the "then" method of your promise. Manually reject that promise using
setTimeout with a delay of 300ms and pass it an Error object with parameter "REJECTED!". There is also boilerplate
code given which should help. The solution should look something like this

var q = require('q');
var defer = q.defer();
defer.promise.then(function(error){
    console.log(error.message);
});
setTimeout(defer.resolve, 300, new Error("REJECTED!"));

As can be seen it is almost identical to the first solution, the official solution does things a small bit different
but is well worth a look.

var q = require('q');
var def = q.defer();
    
function printError (err) {
   console.log(err.message); 
}
    
def.promise.then(null, printError);
setTimeout(def.reject, 300, new Error("REJECTED!"));



Level 03 - To Reject Or Not To Reject
The description of the challenge is fairly lengthy so I will just use the documentations description.
Let's build a simple script to PROVE to ourselves that promises may only resolve
one time and all future attempts to resolve them will simply be ignored.

1. Create a promise using Q.defer
2. Pass console.log as the first AND second argument to your promise's "then" method
3. Resolve the promise with a value of "I FIRED"
4. Reject the promise with a value of "I DID NOT FIRE"

If successful, your script should only log "I FIRED" and should NOT log 
"I DID NOT FIRE".
There is some boilerplate code which can be used in conjunction with previous code and along with the hints it
should mean a significant part of the challenge is already done. The solution itself should look like this

var q = require("q");
var defer = q.defer();

defer.promise.then(console.log, console.log);

setTimeout(defer.resolve, 300, "I FIRED");
setTimeout(defer.reject, 300, "I DID NOT FIRE");

You do not need to put timeout values but reusing previous code from previous example had this timeout so I thought
that it was a good idea to keep in.


Level 4 - Always Async
In this challenge the description of the task is long so I will just copy it to here
In this lesson, we are going to prove to ourselves that this is the case by 
writing a script that does the following:

1. Create a promise using the "Q" library
2. Pass console.log to the "then" method of our promise
*3. Resolve the promise with a parameter "SECOND"
4. Print "FIRST" to the console using console.log

*Do this synchronously and NOT in a setTimeout as was the case in previous lessons

Your script will pass and show you that despite the promise being resolved synchronously,
the provided function is not executed until the next turn of the event loop.

Thus, you should see "FIRST", "SECOND"

As you can see it is fairly similar to what has been done previously so by using the hints and reusing previous
challenges is where to start finding a solution which is fairly straightforward

var q = require('q');
var defer = q.defer();
defer.promise.then(console.log);
defer.resolve("SECOND");
console.log("FIRST");

As you can see the description is longer than the challenge.



Level 5 Values And Promises -
This is the fifth challenge and again it is better to let the site do the talking about the task
Construct a promise chain that returns VALUES to prove to yourself
that promise handlers will wrap your returned values in promises 
allowing additional chaining.

1. Construct a promise using Q's defer
2. Construct a function "attachTitle" which prepends "DR. " to 
   its first argument and returns the result.
3. Build a promise chain off the promise we constructed initially
   that first calls "attachTitle" then calls console.log.
4. Resolve the promise you created with a value of "MANHATTAN".

As you can see the documentation is failr detailed and there is a number of hints which along with using code from
previous example should allow the challenge to be solved quickly enough. The solution should look like

var q = require('q');
var defer = q.defer();

function attachTitle(name){
    return 'DR. ' + name; 
}

defer.promise
.then(attachTitle)
.then(console.log);

defer.resolve("MANHATTAN");

There were not many ways to do this so even the official solution is the same.




Level 6 Throw an error - 
This is the sixth challenge in the series and this time the task is to -
1. Build a function called parsePromised that creates a promise,
   performs JSON.parse in a try/catch block, and resolves or rejects
   the promise depending on whether an error is thrown.
   **NOTE** your function should synchronously return the promise!
2. Build a sequence of steps like the ones shown above that catches
   any thrown errors and logs them to the console.
As can be seen this challenge continues to build upon the previous ones and as has been standard practice code
from previous examples will be reused along with hints and boilerplate from the documentation. The solution itself
will look like this 

var q = require('q');
var defer = q.defer();
var invalidJSON = process.argv[2];

function parsePromised(jsonData){
    try{
        defer.resolve(JSON.parse(jsonData));
    }catch(e){
        defer.reject(e);
    }
    
    return defer.promise;
}

parsePromised(invalidJSON)
    .then(null, console.log);

The solution itself is relatively straightforward having read the documentation and used all the hints etc. The
official solution itself is similar but this one is equally valid.
