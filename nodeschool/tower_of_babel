                        Tower of Babel
      These are my solutions to the Tower of Babel problem series from Nodeschool
                        
Level 1 Setup Babel -                        
The first challenge is to install babel properly and run a hello world like this 
  - npm install babel -g with the g option for global installation
  
Then to run the verification 
  - babel-node program15.js (as my program is program 15)
  



Level 2 Class -
The second challenge of the series asks for an ES6 compatible rewrite of some code provided, the code provided is
var Character = function(x, y) {
      this.x = x;
      this.y = y;
      this.health_ = 100;
    };
    
    Character.prototype.damage = function() {
      this.health_ = this.health_ - 10;
    };
    
    Character.prototype.getHealth = function() {
      return this.health_;
    };
    
    Character.prototype.toString = function() {
      return "x: " + this.x + " y: " + this.y + " health: " + this.getHealth();
    };

The solution is - 
class Character {
    
    constructor(x, y){
      this.x = x;
      this.y = y;
      this.health_ = 100;
    };
    
    damage() {
      this.health_ -=  10;
    };
    
    getHealth() {
      return this.health_;
    };
    
    toString() {
      return "x: " + this.x + " y: " + this.y + " health: " + this.health_;
    };
    }
    
var x = process.argv[2];
var y = process.argv[3];
var character = new Character(+x, +y);
character.damage();
console.log(character.toString());   




Level 3 Class Extend -
In the third challenge of the series there is yet mote boilerplate code which looks like this 
 var util = require('util');
    var Character = function(x, y) {
      this.x = x;
      this.y = y;
      this.health_ = 100;
    };
    
    Character.prototype.damage = function() {
      this.health_ = this.health_ - 10;
    };
    
    Character.prototype.getHealth = function() {
      return this.health_;
    };
    
    Character.prototype.toString = function() {
      return "x: " + this.x + " y: " + this.y + " health: " + this.getHealth();
    };
    
    var Player = function(x, y, name) {
      Character.call(this, x, y);
      this.name = name;
    };
    
    util.inherits(Player, Character);
    
    Player.prototype.move = function(dx, dy){
      this.x += dx;
      this.y += dy;
    };
    
    Player.prototype.toString = function() {
      return "name: " + this.name + " " + Player.super_.prototype.toString.call(this);
    };

This and some other code which will interact with it have to be made es6 compliant so the solution will be -

class Character {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.health_ = 100;
  }
  damage() {
    this.health_ -= 10;
  }
  getHealth() {
    return this.health_;
  }
  toString() {
    return "x: " + this.x + " y: " + this.y + " health: " + this.health_;
  }
}

class Player extends Character {
  constructor(x, y, name) {
    super(x, y);
    this.name = name;
  }
  move(dx, dy) {
    this.x += dx;
    this.y += dy;
  }
  toString() {
    return "name: " + this.name + " " + super.toString();
  }
}

var x = process.argv[2];
var y = process.argv[3];
var name = process.argv[4];
var character = new Character(+x, +y);
character.damage();
console.log(character.toString());
var player = new Player(+x, +y, name);
player.damage();
player.move(7, 8);
console.log(player.toString());
