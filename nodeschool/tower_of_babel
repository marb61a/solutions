                        Tower of Babel
      These are my solutions to the Tower of Babel problem series from Nodeschool
                        
Level 1 Setup Babel -                        
The first challenge is to install babel properly and run a hello world like this 
  - npm install babel -g with the g option for global installation
  
Then to run the verification 
  - babel-node program15.js (as my program is program 15)
  



Level 2 Class -
The second challenge of the series asks for an ES6 compatible rewrite of some code provided, the code provided is
var Character = function(x, y) {
      this.x = x;
      this.y = y;
      this.health_ = 100;
    };
    
    Character.prototype.damage = function() {
      this.health_ = this.health_ - 10;
    };
    
    Character.prototype.getHealth = function() {
      return this.health_;
    };
    
    Character.prototype.toString = function() {
      return "x: " + this.x + " y: " + this.y + " health: " + this.getHealth();
    };

The solution is - 
class Character {
    
    constructor(x, y){
      this.x = x;
      this.y = y;
      this.health_ = 100;
    };
    
    damage() {
      this.health_ -=  10;
    };
    
    getHealth() {
      return this.health_;
    };
    
    toString() {
      return "x: " + this.x + " y: " + this.y + " health: " + this.health_;
    };
    }
    
var x = process.argv[2];
var y = process.argv[3];
var character = new Character(+x, +y);
character.damage();
console.log(character.toString());   




Level 3 Class Extend -
In the third challenge of the series there is yet mote boilerplate code which looks like this 
 var util = require('util');
    var Character = function(x, y) {
      this.x = x;
      this.y = y;
      this.health_ = 100;
    };
    
    Character.prototype.damage = function() {
      this.health_ = this.health_ - 10;
    };
    
    Character.prototype.getHealth = function() {
      return this.health_;
    };
    
    Character.prototype.toString = function() {
      return "x: " + this.x + " y: " + this.y + " health: " + this.getHealth();
    };
    
    var Player = function(x, y, name) {
      Character.call(this, x, y);
      this.name = name;
    };
    
    util.inherits(Player, Character);
    
    Player.prototype.move = function(dx, dy){
      this.x += dx;
      this.y += dy;
    };
    
    Player.prototype.toString = function() {
      return "name: " + this.name + " " + Player.super_.prototype.toString.call(this);
    };

This and some other code which will interact with it have to be made es6 compliant so the solution will be -

class Character {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.health_ = 100;
  }
  damage() {
    this.health_ -= 10;
  }
  getHealth() {
    return this.health_;
  }
  toString() {
    return "x: " + this.x + " y: " + this.y + " health: " + this.health_;
  }
}

class Player extends Character {
  constructor(x, y, name) {
    super(x, y);
    this.name = name;
  }
  move(dx, dy) {
    this.x += dx;
    this.y += dy;
  }
  toString() {
    return "name: " + this.name + " " + super.toString();
  }
}

var x = process.argv[2];
var y = process.argv[3];
var name = process.argv[4];
var character = new Character(+x, +y);
character.damage();
console.log(character.toString());
var player = new Player(+x, +y, name);
player.damage();
player.move(7, 8);
console.log(player.toString());




Level 4 Modules With Name -
Again in the fourth level there is boilerplate code which needs to be adjusted to ES6 style code. In this task
however there is a need for 2 files. The code to be adjusted is this -
  exports.PI = 3.141592;
    
    var _sqrt = function(s, x, last){
      return x != last ? _sqrt(s, (x + s / x) / 2.0, x) : x;
    };
    exports.sqrt = function(s){
      return _sqrt(s, s/2.0, 0.0);
    };
    exports.square = function(x) {
      return x * x;
    };

The solution including both files is this -

Executable -
var arg1 = process.argv[2];
var arg2 = process.argv[3];
import {PI, sqrt, square} from './program15.js' ;

console.log(PI);
console.log(sqrt(+arg1));
console.log(square(+arg2));

Module - 
export const PI = 3.141592;

var _sqrt = function(s, x, last){
  return x != last ? _sqrt(s, (x + s / x) / 2.0, x) : x;
};
export function sqrt(s){
  return _sqrt(s, s/2.0, 0.0);
};
export function square(x) {
  return x * x;
};




Level 5 Modules Default Export -
Again like others in the series this is a reworking of the previous solution, the solution this time round will
be slightly different to the previous one and will look like this -

Executable -
var arg1 = process.argv[2];
var arg2 = process.argv[3];
import Math from './program15.js' ;

console.log(Math.PI);
console.log(Math.sqrt(+arg1));
console.log(Math.square(+arg2));

Module - 
const PI = 3.141592;

var _sqrt = function(s, x, last){
  return x != last ? _sqrt(s, (x + s / x) / 2.0, x) : x;
};
function sqrt(s){
  return _sqrt(s, s/2.0, 0.0);
};
function square(x) {
  return x * x;
};

export default {
  PI: PI,
  square: square,
  sqrt: sqrt
};
